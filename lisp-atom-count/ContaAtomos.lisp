(defun removeSubList(L)
    (cond((null L) ())
         ((and (listp (car L)) (not (null (car L)))) (append (removeSubList (car L)) (removeSubList (cdr L))))
         ((atom (car L)) (cons (car L) (removeSubList (cdr L))))
    )
)

(defun belongsTo(E L)
    (cond  ((null L) nil)
           ((equal (car L) E) t)
           (t (belongsTo E (cdr L)))
    )
)

(defun removeAll(E L)
    (cond  ((null L) ())
           ((equal (car L) E) (removeAll E (cdr L)))
           (t (cons (car L) (removeAll E (cdr L))))
    )
)

(defun removeDuplicates(L)
    (cond ((null L) ())
          ((belongsTo (car L) (cdr L)) (cons (car L) (removeDuplicates (removeAll (car L) L))))
          (t (cons (car L) (removeDuplicates (cdr L))))
    )
)

(defun countElem(E L)
    (cond ((null L) 0)
          ((equal (car L) E) (+ (countElem E (cdr L)) 1))
          (t (countElem E (cdr L)))
    )
)

(defun countAll(L_Orig L_Uniq)
    (cond ((null L_Uniq) ())
          (t (cons (list (car L_Uniq) (countElem (car L_Uniq) L_Orig)) (countAll L_Orig (cdr L_Uniq))))
    )
)

(defun main(L)
    (pprint (countAll (removeSubList L) (removeDuplicates (removeSubList L))))
)
